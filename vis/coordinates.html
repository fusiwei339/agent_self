<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.js"></script>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>

<script>

    // set the dimensions and margins of the graph
    const margin = {top: 30, right: 10, bottom: 20, left: 0},
      width = 500 - margin.left - margin.right,
      height = 200 - margin.top - margin.bottom;
    
    // append the svg object to the body of the page
    const svg = d3.select("#my_dataviz")
    .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform",
            `translate(${margin.left},${margin.top})`);
    
    function flatdata(json){
      let ret=[]
      let dimension=["gpt-4o", "gpt-4-turbo-preview", "gpt-4-0613", "gpt-3.5-turbo", "gpt-3.5-turbo-1106"]
      for (let i = 0; i < json.length; i++) {
        let e= json[i];
        for (let j = 0; j < dimension.length; j++) {
          let d= dimension[j];
          ret.push({model:d, val: e[d], round: e.round})
        }
      }
      return ret
    }
    function preprocess(json){
      let ret=[]
      let dimension=["gpt-4o", "gpt-4-turbo-preview", "gpt-4-0613", "gpt-3.5-turbo", "gpt-3.5-turbo-1106"]
      json.sort((a, b)=>{
        if(a.sum==b.sum){
          if(b[dimension[0]] == a[dimension[0]]){
            if(b[dimension[1]] == a[dimension[1]]){
              if(b[dimension[2]] == a[dimension[2]]){
                if(b[dimension[3]] == a[dimension[3]]){
                  return b[dimension[4]]-a[dimension[4]]
                }
                return b[dimension[3]]-a[dimension[3]]
              }
              return b[dimension[2]]-a[dimension[2]]
            }
            return b[dimension[1]]-a[dimension[1]]
          }
          return b[dimension[0]]-a[dimension[0]]
        }
        return b.sum-a.sum
      })

      for (let i = 0; i < json.length; i++) {
        let e= json[i];
        let tmp={sum:e.sum, round:e.round, path:[]}
        for (let j = 0; j < dimension.length; j++) {
          let d= dimension[j];
          tmp.path.push({model:d, val:e[d], kind:"ori"}, {model:d, val:e[d], kind:"dup"}) 
        }
        ret.push(tmp)
      }
      return ret
    }
    d3.json("json/gptmix_neutral_percent_self_0.7_None.csv.json").then(function(origin){
      origin=origin
      data=preprocess(origin)
      let dimension=["gpt-4o", "gpt-4-turbo-preview", "gpt-4-0613", "gpt-3.5-turbo", "gpt-3.5-turbo-1106"]
      let yband=d3.scaleBand()
          .domain([0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50])
          .range([height, 0])
      let ylinear=d3.scaleLinear()
          .domain([0, 50])
          .range([height, 0])
      let x = d3.scalePoint()
        .range([0, width])
        .domain(dimension)
        .padding(1)
      const colorScale = d3.scaleSequential(d3.interpolateBlues)
          .domain([0, 70])

      let axisWidth=10

      let histogram={} 
      for(let i=0;i<dimension.length;i++){
        let d=dimension[i]
        let h=d3.histogram()
          .value(e=>e[d])
          // .domain(yband.domain())
          .thresholds(yband.domain());
        histogram[d]=h(origin)
      }
      let barData=Object.keys(histogram).map(function(key){return {model:key, rects:histogram[key]}})
      console.log(barData);

      function drawline(d) {
          return d3.line()(d.path.map(e=>{
            if(e.kind==="ori"){
              return [x(e.model), ylinear(e.val)]
            }
            return [x(e.model)+axisWidth, ylinear(e.val)]
          }));
      }

      svg
        .selectAll("myPath")
        .data(data)
        .join("path")
        .attr("d",  drawline)
        .style("fill", "none")
        .style("stroke", "#69b3a2")
        .style("opacity", 0.3)

      svg.selectAll('g')
        .data(barData)
        .enter().append('g')
        .attr('transform', d=>"translate("+x(d.model)+", 0)")
        .selectAll('rect')
        .data(d=>d.rects)
        .enter().append('rect')
        .attr('x', 0)
        .attr('y', e=>yband(e.x0))
        .attr('width', axisWidth)
        .attr('height', yband.bandwidth())
        .style('fill', e=>colorScale(e.length))
        .style('stroke', e=>colorScale(e.length))

      svg.selectAll("myAxis")
        .data(dimension).enter()
        .append("g")
        .attr("transform", function(d) { return "translate(" + x(d) + ")"; })
        .each(function(d) { 
          d3.select(this).call(d3.axisLeft().scale(ylinear).tickValues([0, 50])); 
          d3.select(this).select('path').style('opacity',0)
          d3.select(this).select('line').style('opacity',0.1)
        })
        .append("text")
          .style("text-anchor", "middle")
          .attr("y", height+12)
          .text(function(d) { return d; })
          .style("fill", "black")

      let data2=flatdata(origin)
      let boxdata=d3.rollups(data2, g=>{
        let mean=d3.mean(g, e=>e.val)
        let sd=d3.deviation(g, e=>e.val)
        return {mean, sd}
      }, d=>d.model)

      console.log(boxdata);

      let color="#222"
      let symbolG=svg.append("g")
            .attr("class", "errorBarG")

      let erroebarG=symbolG.selectAll('g').data(boxdata)
        .enter().append('g')
        .attr('transform', d=>"translate("+x(d[0])+", 0)")

      erroebarG.append("path")
          .attr("d", d=>{
              let offset=2
              let p=d3.path()
              // Vertical line
              p.moveTo(axisWidth/2, ylinear(d[1].mean - d[1].sd))
              p.lineTo(axisWidth/2, ylinear(d[1].mean + d[1].sd))
              // Bottom error bar
              p.moveTo(axisWidth/2 - offset, ylinear(d[1].mean - d[1].sd))
              p.lineTo(axisWidth/2 + offset, ylinear(d[1].mean - d[1].sd))
              // Top error bar
              p.moveTo(axisWidth/2 - offset, ylinear(d[1].mean + d[1].sd))
              p.lineTo(axisWidth/2 + offset, ylinear(d[1].mean + d[1].sd))
              return p.toString()
          })
          .attr("stroke", color)
          .attr("stroke-width", 1)

      erroebarG.append("circle")
          .attr("cx", axisWidth/2)
          .attr("cy", d=>ylinear(d[1].mean))
          .attr("r", 1.5)
          .style("stroke", color)
          .style("fill", color)

      let format=d3.format(".2f");
      
      erroebarG.each(function(d){
        let canvas=d3.select(this)
        let tmp=[d[1].mean, d[1].mean-d[1].sd, d[1].mean+d[1].sd]
        canvas.selectAll('text').data(tmp)
          .enter()
        .append('text')
          .attr('class', "meantext")
          .attr('x', -9)
          .attr('dy', '0.32em')
          .attr('y', e=>ylinear(e))
          .text(e=>format(e))
          .style("fill", "black")
          .style("text-anchor", "end")
          .style("font-size", "11px")
      })

    })

    </script>